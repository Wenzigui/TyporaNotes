[toc]



# 原因

将数据存放在单一节点，从性能、可用性以及运维成本来看，都无法满足海量数据的需求



分表：解决单表数据量大的问题

分库：解决单库性能问题



# 需要关注的几个点？

1.  中间件怎么选？
    目前市面上分库分表的中间件可以划分为两类：client类型和proxy类型，两种方案各有优缺点
2.  全局唯一ID怎么选择？
    目前基本都是使用雪花算法
3.  分片键怎么选择？
4.  迁移方案怎么选择？
    新旧库迁移的时候停不停机？对于历史数据、新增数据要怎么处理？
5.  迁移后，新旧库数据一致性怎么校验？



# 中间件选择

目前市面上的分库分表中间件主要大体分成两类：client模式、proxy模式



-   client 模式
    -   TDDL：阿里开源，支持读写分离，但不支持join表，使用时需要依赖指定的配置管理系统，基本没人用
    -   Sharding JDBC：目前很火，被大量互联网公司所采用
        -   优点：不用部署，运维成本低，不需要proxy层二次转发请求，性能高
        -   缺点：每个系统都需要耦合sharding jdbc的依赖，而且sharding jdbc是一个java框架，无法实现跨语言的需求
-   proxy 模式
    -   Cobar：阿里开源，不支持读写分离，跨库join表，分页等操作，基本没人用
    -   MyCat：基于Cobar改造，功能完善，比较火（推荐）
    -   Atlas：360开源，基本没人用
    -   Sharding Proxy：有跨语言需求（Go，PHP），可以考虑这个



# 全局唯一ID选择

![image-20200704102557716](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704102557716.png)



## UUID

32位16进制数字，通过连字号分为五段，形式为8-4-4-4-12的36个字符

>   示例：550e8400-e29b-41d4-a716-446655440000



优点：

-   本地生成，性能高，没有网络消耗



缺点：

-   不易于存储：UUID太长，128位，通常以36长度的字符串表示，很多场景不适用。
-   信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
-   ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用



## Snowflake

这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标识机器、时间等，比如在snowflake中的64-bit分别表示如下图所示：

![image-20200704103631593](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704103631593.png)

-   41bit：表示时间戳，可以记录69年
-   10bit：可以容纳1024台机器
-   12bit：表示每台机器可以支持2^12个自增序列号ID

>    理论上snowflake方案的QPS约为409.6w/s
>
>   这种分配方式可以保证在任何一台机器在任意毫秒内生成的ID都是不同的



优点：

-   ID都是趋势递增: 毫秒数在高位，自增序列在低位
-   第三方弱依赖: 不依赖数据库等第三方系统
-   稳定性,性能高: 以服务的方式部署，稳定性更高，生成ID的性能也是非常高的
-   位数分配灵活: 可以根据自身业务特性分配bit位，非常灵活



缺点：

-   强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态



## 数据库生成

利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增



优点：

-   非常简单，成本低
-   ID单调递增



缺点：

-   强依赖DB
-   ID发号性能受限于单台MySQL的读写性能



## Redis生成

依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。



优点：

-   不依赖于数据库，灵活方便，且性能优于数据库
-   ID单调递增



缺点：

-   Redis不可用时,系统也不可用



## zookeeper生成

zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号

>   很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。



# 分片键选择

>   一般根据表的用途，选择分片键

-   信息表，根据主键ID进行分片（文章、商品等）
-   业务表，根据用户ID进行分片（订单，支付等）
-   日志表，根据创建时间进行分片



# 迁移方案



## 停机部署

![image-20200704112924008](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704112924008.png)

## 基于业务，双写部署

![image-20200704112947729](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704112947729.png)



## 基于bin log，双写部署

![image-20200704113026634](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704113026634.png)



# 新旧库数据一致性校验方案

-   检验数据量
-   校验具体字段
    -   只验关键性的几个字段是否一致
    -   旧库取定量数据通过字符串拼接的形式，进行MD5加密，新库也是，然后比较加密结果是否一致


