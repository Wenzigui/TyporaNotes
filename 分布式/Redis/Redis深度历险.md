# 分布式锁

分布式锁的本质就是**占坑**，使用redis提供的`setnx`指令



## finally问题

最简单的分布式锁实现 setnx key -> del key先添加锁，然后代码执行完后，显示delete锁这种做法的最大问题在于，如果在程序运行期间抛出异常，且没有通过finally机制显示删除锁，会导致死锁现象（redis中一直存在锁）



为了解决上面这种问题，可以通过给锁设定过期时间来解决

```shell
setnx #{key} #{value} -> expire #{key} #{time}
```



## 原子操作问题

但是这样又会衍生出来一个问题，**加锁和给锁设置过期时间这两个动作并不是一个原子操作**，如果在加锁之后，给锁设置过期时间之前，redis无故宕机，同样会导致死锁现象



为了解决这个问题，redis2.8对set指令进行扩展，允许setnx指令和expire指令一起执行

```shell
set #{key} #{value} ex #{time} nx
```



## 超时释放锁问题

一个线程在redis设置一个带过期时间的分布式锁后，执行业务逻辑。在出现业务逻辑执行时间长于加锁时间的时候，线程释放锁的时候，实际上是释放别的线程添加的分布式锁。



要解决这种问题，可以通过随机值解决，在设置分布式锁的时候，锁的value可以设置一个随机值，释放锁的时候，可以比较锁中的随机值跟线程当前的随机值，如果不相等，则不释放锁。



这个问题同样从侧面反映出来，**redis的分布式锁不适用于执行时间过长的业务逻辑**，同时在使用分布式锁的时候要合理评估锁的过期时间



## 可重入问题

同一个线程对分布式锁的可重入性可以通过ThreadLocal解决（不过不推荐，因为对于带过期时间的分布式锁，维护起来很麻烦）



## 单实例加锁问题

在sentinel集群环境中分布式锁的问题（单实例加锁问题）：  在sentinel集群中，在加锁的过程中，主节点在成功加锁后，在从节点同步之前，主节点宕机，此时从节点会取代主节点，从而导致加锁失败，此时其他客户端继续对redis加锁。这样就相当于，两个不同的客户端持有同一把锁。  



为了解决这个问题，可以使用**RedLock算法**，该算法需要依赖多个Redis实例（实例之间互相独立，不是主从关系），加锁时会向集群中过半节点发送`set ex nx`指令，只要过半节点加锁成功，则认为加锁成功，否则失败。



## 加锁失败后处理方式

抛出异常sleep重试/自旋重试将请求转移到延时队列，过会儿再重试



# HyperLogLog



## 应用场景

统计某个网页每天的UV数量（统计基数）



## 分析

UV跟PV不同，UV需要去重，说白了就是，同一个用户，在同一天内多次进入同一个页面，UV只会+1



## 解决方案

-   可以通过Redis的set集合进行去重，但是对于几千万个UV级别的页面来说，需要非常大的set集合，浪费内存

-   通过Redis的高级数据类型HyperLogLog统计UV



HyperLogLog：提供不精确的去重计数方案，标准误差0.81%



## 命令

-   pfadd：增加计数
-   pfcount：获取计数
-   pfmerge：将多个pf计数值合并成新的pf计数值



HyperLogLog的优点：在计数较小的时候，采用稀疏矩阵存储，空间占用小在计数很大的时候，占据12KB