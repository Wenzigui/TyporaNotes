[toc]

# 缓存雪崩

缓存雪崩是指缓存机器意外宕机，导致请求落在数据库中

![image-20200704164412999](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704164412999.png)

解决方案：

1.  缓存高可用（Redis哨兵模式、集群模式）
2.  本地缓存
3.  DB限流，服务降级



# 缓存穿透

缓存穿透是指某些恶意的请求，在缓存中查不到，然后落到数据库中（视缓存如无物）

![image-20200704164115876](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704164115876.png)



解决方案：

1.  缓存空对象

    ![image-20200704164638773](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704164638773.png)

    缓存空对象方案的问题：

    1.  空值做缓存，意味着需要占用更多的内存空间，这个问题一般通过给这类数据设置较短的过期时间来解决

    2.  缓存层和DB层会有一段时间窗口出现数据不一致，可能会对业务造成影响，此时需要考虑使用“保持缓存和数据库一致性”的解决方案

        >   比方说，一个数据，查询的时候是没有的，设置了五分钟的过期时间，然后五分钟之内，这个数据被新增到数据库了，此时缓存层没有，DB层有数据，出现数据不一致的情况



2.  布隆过滤器

适用于数据命中不高，数据相对固定实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。

![image-20200704165546871](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704165546871.png)



|          | 缓存空对象                                       | 布隆过滤器                   |
| -------- | ------------------------------------------------ | ---------------------------- |
| 适用场景 | 数据频繁变化                                     | 数据相对固定                 |
| 维护成本 | 代码维护简单，占用内存空间大，存在数据一致性问题 | 代码维护复杂，占用内存空间少 |



# 缓存击穿

缓存击穿是指某个访问非常频繁的热点key，在key失效的瞬间，请求击穿缓存落到数据库



解决方案：

1.  互斥锁

只允许一个线程去更新缓存，其他线程则等待该线程执行完，再从缓存中获取数据

![image-20200704171000980](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704171000980.png)



2.  永不过期

对于热点key在缓存层不设置过期时间，在业务层设置逻辑过期时间，当发现超过逻辑过期时间后，使用单独的线程去更新缓存

![image-20200704171344553](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704171344553.png)

这个方案的问题在于，会存在一段时间窗口出现数据不一致，此时需要视乎业务能否容忍这种数据不一致性



![image-20200704171520805](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704171520805.png)



# 缓存和数据库的一致性如何保证？

产生原因：

1.  高并发场景下，读到旧数据，更新到缓存中（先删除缓存，再更新数据库）
2.  缓存操作和DB操作无法保证原子性，一个操作成功，一个操作失败，导致不一致性



解决方案：

1.  如果是先删除缓存，再写数据库，可以引入分布式锁
    -   在写请求时，先淘汰缓存之前，先获取该分布式锁
    -   在读请求时，发现缓存不存在时，先获取分布式锁

![image-20200704180443655](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200704180443655.png)



2.  如果是先写数据库，再删除缓存，可以按需考虑一下两种方案

    -   更新数据库后，通过定时任务来删除缓存（确保最终一致性）
    -   更新数据库后，通过可靠消息来删除缓存（确保最终一致性）

    >   实际上这就是分布式事务解决方案里面的“本地消息表”和“可靠消息最终一致性”的这两种方案



