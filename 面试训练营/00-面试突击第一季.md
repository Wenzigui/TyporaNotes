[toc]

# Dubbo相关



## 为什么要进行系统拆分？如何进行系统拆分？

拆分的原因：

-   单体应用无法在高并发请求以及海量数据存储的情况下有良好的性能表现，仅通过集群提高系统性能会浪费系统资源
-   单体应用中一个模块的改动，会涉及到整个应用的回归测试，上线
-   多人同时维护一个单体应用容易出现代码冲突，开发效率低下



系统拆分原则：

![image-20200603211612593](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200603211612593.png)



## Dubbo的工作原理？

dubbo架构分为10层

1.  第一层：service 层，接口层，给服务提供者和消费者来实现的
2.  第二层：config 层，配置层，主要是对 dubbo 进行各种配置的
3.  第三层：proxy 层，服务代理层，无论是 consumer 还是 provider，dubbo 都会给你生成代理，代理之间进行网络通信
4.  第四层：registry 层，服务注册层，负责服务的注册与发现
5.  第五层：cluster 层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务
6.  第六层：monitor 层，监控层，对 rpc 接口的调用次数和调用时间进行监控
7.  第七层：protocol 层，远程调用层，封装 rpc 调用
8.  第八层：exchange 层，信息交换层，封装请求响应模式，同步转异步
9.  第九层：transport 层，网络传输层，抽象 mina 和 netty 为统一接口
10.  第十层：serializer 层，数据序列化层



工作流程：

1.  provider服务启动，向注册中心注册服务地址
2.  consumer从注册中心订阅服务
3.  注册中心会在服务发生变更的时候，推送服务地址信息给订阅该服务的consumer
4.  consumer根据服务地址信息调用provider
5.  监控中心定时采集服务调用相关的信息

![image-20200603213728163](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200603213728163.png)

>   详细版

![image-20200603213802371](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200603213802371.png)

>   简化版



## 注册中心挂了还可以继续通信吗？

可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息**拉取到本地缓存**，所以注册中心挂了可以继续通信。



## Dubbo支持那些通信协议，序列化协议？

支持的通信协议：

-   dubbo（默认）：单一长连接，NIO异步通信，使用hessian做序列化协议，合适”传输数据量小，并发量高“的场景
-   rmi：短连接，适合文件传输，使用java二进制序列化协议
-   webservice
-   http
-   hessian：短连接，适合文件传输，使用hessian做序列化协议
-   memcache
-   redis



支持的序列化协议：

-   hessian2（默认）
-   java二进制序列化协议
-   json
-   dubbo



## Dubbo负载均衡策略

-   随机（调用次数越多，越均匀）
-   轮询（存在请求积累问题），可以调整权重
-   最少活跃调用
-   一致性hash策略：相同参数的请求一定分发到同一台机器上



## Dubbo集群容错策略

-   failover：请求失败后重试
-   failfast：请求失败后不重试
-   failsafe：出现异常的时候，直接忽略异常，佛系调用
-   failback：请求失败后，记录在失败队列中，由线程池定时重试，适用于异步或要求最终一致性的请求
-   forking：同时调用多个服务，其中一个返回，则立即返回结果
-   broadcast：广播调用所有可用的服务，任一节点报错则报错，常用于服务状态更新后的广播
-   mock：调用失败的时候，返回伪造的响应结果
-   available：不做负载均衡，遍历所有服务列表，找到第一个可用的节点，直接请求并返回结果
-   mergeable：将多个节点请求得到的结果进行合并



## Dubbo的SPI思想是什么？

>   基于Dubbo SPI加载机制，让整个框架接口与具体实现完全解耦，从而奠定了整个框架良好可扩展性的基础



Dubbo SPI没有直接使用Java SPI，而是在它的思想上又做了一定的改进，形成自己的配置规范和特性，同时Dubbo SPI又兼容Java SPI。



SPI实际上就是**根据指定/默认的配置，找到对应的实现类，加载这个实现类的实例对象**



Java的SPI思想体现在JDBC上



Dubbo SPI的改进与优化：

1.  JDK标准的SPI会一次性实例化扩展点的所有实现，耗时，如果用不上，则浪费资源；而Dubbo SPI不会立即全部初始化，只是加载配置文件中的类，缓存在内存中，性能上有更好的表现
2.  JDK SPI在扩展点加载失败的时候，会掩盖真实的异常信息，导致问题追踪困难；Dubbo在扩展点加载失败时先抛出真实异常并打印日志
3.  Dubbo SPI添加了对扩展点IOC和AOP的支持



