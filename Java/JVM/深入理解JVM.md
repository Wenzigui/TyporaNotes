[toc]



#  垃圾收集器与内存分配策略

![image.png](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/1578703206113-0522bdc7-9642-433d-ab2d-6b24936208f1.png)

> 城外的人想进来，城内的人想出去



## GC要达成什么？

1. 什么内存需要回收？
> 堆、方法区中无用（死去）的对象
> 延伸：那怎么判断对象无用？

2. 什么时候回收？
> - 发生young gc的条件
> - 发生old gc的条件

3. 如何回收？
> GC的算法



## 判断对象已死



### 引用计数法

定义：

给对象添加一个引用计数器，每当由一个地方引用它的时候，计数器值+1；当引用失效的时候，计数器值-1；当计数器的值为0的时候，表示对象已死（可以被回收）

优点：

- 实现简单
- 判定高效

缺点:

- 无法解决对象之间互相循环引用问题



### 可达性分析法

![image.png](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/1578704901185-a532a1bc-f020-4779-bae1-af5fa3e6bd9c.png)



定义：

一个对象到GC Roots之间没有任何引用链相连，那么可以判断这个对象是不可用的
> - 不可用不代表一定要回收它
> - 常见的GC Roots有局部变量、静态变量，常量
> - 引用链就是GC Roots到对象之间的路径



#### GC Roots对象

- 虚拟机栈中栈帧的本地变量表中引用的对象（常见）
> Xxx xxx = new Xxx();

- 方法区中类静态属性引用的对象（常见）
> static xxx = new Xxx();

- 方法区中常量引用的对象（常见）
> static final xxx = new Xxx();

- 本地方法栈中JNI引用的对象（最少接触）



#### 四种引用

- 强引用
垃圾收集器永远不会回收
- 软引用
系统即将发生内存移除时，软引用指向的对象会被垃圾收集器回收
- 弱引用
发生GC时，无论内存是否足够，都会被回收掉
- 虚引用
引用存在与否都不会影响对象的生存时间



#### 真正宣告对象死亡

> 不可达的对象并不是非死不可，想要宣告一个对象死亡，至少要经历两次标记过程

第一次标记：
通过可达性分析法判断对象不可达的时候，进行第一次标记，此时会把有必要执行finalize方法的对象放置在`F-Queu`队列中

> 如果对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，就会判断对象没必要执行finalize方法
>
> - finalize方法只会被调用一次


第二次标记：
处于F-Queue队列中的对象，会有一个由**JVM创建**，**低优先级**的线程**触发**对象的finalize方法，在此过程中GC会对F-Queue中的对象进行第二次的标记，**如果对象在finalize方法中重新跟GC Root关联，那么该对象会成功拯救自己（不会被垃圾回收）**
> 并不建议，也不鼓励使用finalize方法拯救对象

## 回收方法区

方法区的垃圾回收主要有两部分：

- 废弃常量
- 无用的类

废弃常量的判断条件：常量池中没有任何引用

无用类的判断条件：

1. 该类的所有实例对象都已经被回收了
1. 加载该类的ClassLoader已经被回收了
1. 该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
> 以上三个条件都必须要满足，才能算是无用的类

## 垃圾收集算法

### 标记-清除算法

> 最基础的垃圾收集算法，此后的算法都是基于此，朝着解决此算法的问题出发


步骤：

1. 标记出所有需要回收的对象
1. 统一回收所有被标记的对象

缺点：

1. 标记和清除过程的效率不高
1. 标记清除后会产生大量不连续的内存碎片

### 复制算法

步骤：

1. 将可用内存划分为大小相等的两块，每次只使用其中一块
1. 当其中一块内存用完的时候，将这块内存中存活的对象复制到另一块
1. 将已使用的内存空间一次清理掉
> 复制的对象都是存活的对象


缺点：

1. 当复制大量的对象的时候，性能低下（合适小量内存复制）

### 标记-整理算法

步骤：

1. 标记出所有需要回收的对象
1. 将所有存活的对象向一端移动
1. 直接清除端边界以外的内存

## 垃圾收集器

![image.png](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/1578756268986-5b668277-820c-4ab2-a35a-3658335f3491.png)

![](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/1583903876343-dd6e4068-1e74-4814-a846-f4f5771f22bf.svg)
### 垃圾收集器中的并发&并行

并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

并发：指用户线程与垃圾收集线程同时执行

## 内存分配&回收策略

### Minor GC和Full GC的区别

Minior GC：指发生在新生代的垃圾收集动作，由于新生代中的对象大都是朝生夕灭，所以Minor GC执行非常频繁，回收速度也比较快
> Minor GC也可以叫做Young GC


Full GC：指发生在老年代的GC，Full GC通常会伴随着最少一次的Minor GC
> Full GC也叫Major GC

### 大对象直接进入老年代

> 需要大量连续内存的对象就是大对象
> 典型的大对象：
> - 数组
> - 字符串


-XX:PretenureSizeThreshold参数：
大于这个参数设置的值将直接分配在老年代，这样有个好处就是：避免新生代中发生大量的内存复制
> 仅对Serial和ParNew收集器有效

### 长期存活的对象进入老年代

虚拟机给每个对象定义了一个对象年龄计数器，对象在eden区经历过第一次Young GC后存活，对象的年龄设置为1，此后该对象每次从Young GC中survive下来，年龄+1，当对象的年龄达到一定程度的时候，该对象会被晋升到老年代中。
> 可以通过参数-XX:MaxTenuringThreshold设置

### 动态对象年龄判断

> 虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才晋升老年代


如果在survivor空间中相同年龄所有对象大小总和大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄

### 空间分配担保

在发生young gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么young gc是安全的；否则需要查看是否开启空间分配担保，如果空间分配担保开启了，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则可以冒险进行一次young gc；否则将进行一次full gc

![image.png](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/1578822685647-9c5149b2-94c4-4dd2-91ad-e7cc9db135b1.png)



# 类加载机制



## 定义

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被JVM直接使用的Java类型

>   加载、连接、初始化过程都是在程序运行期间完成的



## 类的生命周期



![image](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/c126fb4f-7c3b-4493-b2e8-9ed82b95e1b3-2801217.jpg)



加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的

>   解析阶段在某些情况下，可以在初始化阶段之后再开始



### 初始化时机

虚拟机规范规定，以下5种场景需要立即对类进行初始化工作：

1.  遇到特定字节码指令的时候
    字节码指令：new、getstatic、putstatic、invokestatic
    1.  使用new关键字实例化对象
    2.  set/get类的静态字段（排除final修饰的字段）
    3.  调用类的静态方法
2.  对类进行反射操作的时候
3.  初始化一个类的时候，必须先初始化其父类
4.  虚拟机启动的时候，用户执行执行的主类
    包含main方法的类
5.  MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，句柄所对应的类要初始化



### 主动引用 & 被动引用

主动引用：以上5种场景成为对类的主动引用



被动引用：除主动引用以外，其余时被动引用



![image](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/78d96a5f-3d7a-4cfb-b61e-1c86eca41628-2801217.jpg)

1.  代码不会触发SuperClass的初始化，但是会触发由JVM自动生成的SuperClass的数组类的初始化 
2.  该数组类由字节码指令newarray触发



![image](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/2ebd9c3e-772b-496c-bc16-c72a464205b3-2801217.jpg)



### 接口加载和类加载的区别

-   接口中不能使用static代码块
-   接口在初始化的时候，不要求其父接口都完成了初始化，只有在使用到父接口的时候，才会初始化



## 类加载过程



### 加载

加载阶段，虚拟机需要完成3件事：

1.  通过类的全限定名获取类的二进制字节流
2.  将字节流所代表的静态存储结构转化为方法区中的运行时数据结构
3.  在内存中生成字节流的class对象



数组类和非数组类的加载过程对比：

-   非数组类：可控性强，可以自定义类加载器区加载
-   数组类：不通过类加载器创建，由JVM直接创建



### 连接

>   加载阶段与连接阶段的部分内容是交叉进行的



#### 验证

目的：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身的安全



文件格式验证：验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理

-   通过这个阶段的验证后，字节流才会进入内存的方法区中进行存储



元数据验证：对字节码的描述信息进行语义分析

-   是否有父类
-   是否继承了不允许被继承的父类
-   非抽象类是否实现了父类或接口中要求实现的方法
-   …



字节码验证：通过数据流和控制流分析，确定程序语义是否合法、符合逻辑



符号引用验证：确保解析动作能正常执行

-   发生在解析阶段，虚拟机将符号引用转化为直接引用的时候



#### 准备

目的：为类变量在方法区分配内存并设置初始值（不包括实例变量）

类变量为常量值（final修饰），在这个阶段会为变量初始化为指定的常量

```java
public static final int value = 123;
```



#### 解析

目的：虚拟机将常量池内的符号引用替换为直接引用的过程



符号引用

-   用一组符号来描述所引用的目标
-   与虚拟机实现的内存布局无关
-   引用的目标不一定已经加载到内存中



直接引用

-   直接指向目标的指针、相对偏移量或能间接定位目标的句柄
-   与虚拟机实现的内存布局相关
-   引用的目标一定已经加载到内存中



虚拟机规范要求，在执行某些字节码指令之前，要相对其使用的符号引用进行解析

>   anewarray、checkcast、getfield、getstatic、instanceof、...

虚拟机可以实现对解析结果的缓存，避免执行重复的解析动作

>   除了invokedynamic命令



解析动作主要针对7类符号引用进行：

-   类或接口
-   字段
-   类方法
-   接口方法
-   方法类型
-   方法句柄
-   点限定符



### 初始化

初始化阶段是执行类构造器\<clinit\>()方法的过程



\<clinit\>()方法

-   由编译器自动收集类中所有类变量的赋值动作和静态代码块合并产生
-   虚拟机会确保在子类的\<clinit\>()方法执行前，父类的\<clini\>()方法已经执行完毕
-   \<clinit\>()方法对于类或接口来说并不是必需的
-   多个线程同时初始化一个类，只会有一个线程执行\<clinit\>()方法，其余线程都要阻塞等待



## 类加载器

作用：让应用程序自己去决定如何获取所需要的类



对于任意一个类，需要通过这个类本身以及加载这个类的类加载器来确立在JVM中的唯一性

>   也就是说，比较两个类是否相等的前提条件是，这两个类都使用同一个类加载器加载



### 双亲委派模型

![image](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/7b5aa578-bee6-4319-8b87-caa5be06a2e6-2801217.jpg)



### 类加载器种类

-   启动类加载器
    类加载范围：(JAVA_HOME/lib目录 || -Xbootchasspath参数指定的路径) && JVM能识别(特定文件名)
-   扩展类加载器
    类加载范围：JAVA_HOME/lib/ext目录 || 被java.ext.dirs系统变量所指定的路径中所有类库
-   应用程序类加载器
    类加载范围：负责加载用户类路径上所指定的类库

>   -   除了启动类加载器，其余的类加载器都应当有自己的父类加载器
>   -   加载器之间的父子关系通过组合关系实现，不是继承