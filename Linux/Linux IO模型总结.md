[toc]

>   一次IO操作，数据会先被拷贝到操作系统内核缓冲区，然后再拷贝到应用程序的地址空间
>
>   所以，当一个read操作发生的时候，会经历两个阶段：
>
>   1.  等待数据准备就绪
>   2.  将数据从内核拷贝到进程中



# 阻塞IO

>   我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。

在这个IO模型中，用户空间的应用程序执行一个系统调用，会导致应用程序阻塞

![image-20200705094755803](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200705094755803.png)

用户进程在两个阶段都是陷入阻塞状态



# 非阻塞IO

>   我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。

![image-20200705095401501](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200705095401501.png)

-   用户进程在第一阶段不会陷入阻塞状态，可以不停地主动轮询内核，看数据准备好了没有
-   第二阶段仍然会陷入阻塞状态



# 多路复用IO

>   餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的 IO 多路复用。
>
>   -   UNIX/Linux 下的 select、poll、epoll 就是干这个的 (epoll 比 poll、select 效率高，做的事情是一样的)
>   -   I/O 复用模型会用到 select、poll、epoll 函数，这几个函数也会使进程阻塞

![image-20200705100039695](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200705100039695.png)

select/poll/epoll的好处在于**单个线程可以同时处理多个socket**

用户进程在第一阶段仍然是阻塞的（被select调用阻塞）

>   如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用 multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。



# 异步IO

>   女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。

![image-20200705110249571](https://images-1255831004.cos.ap-guangzhou.myqcloud.com/online/image-20200705110249571.png)

用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到 socket 数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知

用户进程在两个阶段都是非阻塞状态的



# 小结



## 关于同步&异步、阻塞&非阻塞

-   同步&异步是指在进行系统调用的时候，消息通知的方式
-   阻塞&非阻塞是指在应用程序等待通知的时候，自身的状态（是否让出CPU资源）



## 横向对比

|                                        | BIO  | NIO    | IO多路复用 | AIO    |
| -------------------------------------- | ---- | ------ | ---------- | ------ |
| 第一阶段（等待数据准备就绪）           | 阻塞 | 非阻塞 | 阻塞       | 非阻塞 |
| 第二阶段（从内核拷贝数据进入用户空间） | 阻塞 | 阻塞   | 阻塞       | 非阻塞 |



## IO多路复用中的select、poll、epoll

-   select：当有IO流时间产生的时候，唤醒进程去处理，**进程会轮询所有连接（最多1024个）**
-   poll：当有IO流时间产生的时候，唤醒进程去处理，**进程会轮询所有连接（无限个连接）**

>   可以看到，select、poll都是很耗费CPU资源的，性能不咋地

-   epoll：当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个连接

>   牛逼！高效！但是只有linux支持，windows要实现多路复用依赖iocp



epoll和select、poll的区别：

1.  epoll使用mmap，避免数据来回拷贝
2.  epoll基于事件驱动，避免轮询，节省CPU资源